1/ 实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。
	例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，
	并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。
	我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。
2/ 开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。
3/ 死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。



1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：
　　　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；
　　　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；
　　　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。
2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。(流量控制等)